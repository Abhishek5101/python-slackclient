from typing import List, Union

from .elements import BlockElement, InteractiveElements
from .objects import JsonObject, MarkdownTextObject, PlainTextObject, TextObject
from ...errors import SlackObjectFormationError


class Block(JsonObject):
    attributes = {"type", "block_id"}

    def __init__(self, type: str, block_id: str = None):
        self.type = type
        self.block_id = block_id
        self.color = None

    def get_json(self) -> dict:
        if self.block_id is not None and len(self.block_id) > 255:
            raise SlackObjectFormationError(
                "Block ID must not exceed 255 characters if specified"
            )
        return self.get_non_null_keys(self.attributes)


class DividerBlock(Block):
    def __init__(self):
        """
        A simple divider - equivalent to <hr>
        https://api.slack.com/reference/messaging/blocks#divider
        """
        super().__init__(type="divider")


class SectionBlock(Block):
    def __init__(
        self,
        text: Union[str, TextObject] = None,
        fields: List[str] = None,
        block_id: str = None,
        accessory: BlockElement = None,
    ):
        """
        A general purpose block capable of holding text, fields (displayed in a
        semi-tabular format) and one 'accessory' element
        https://api.slack.com/reference/messaging/blocks#section

        :param text: either a plain string, or a richer TextObject

        :param fields: optional: a sequence of strings that will be rendered using
        MarkdownTextObjects

        :param block_id: ID to be used for this block - autogenerated if left blank.
        Cannot exceed 255 characters.

        :param accessory: an optional BlockElement to attach to this SectionBlock as
        secondary content
        """
        super().__init__(type="section", block_id=block_id)
        self.text = text
        self.fields = fields or []
        self.accessory = accessory

    def get_json(self) -> dict:
        if self.text is None and self.fields is None:
            raise SlackObjectFormationError(
                "text or fields attribute must be populated"
            )
        if self.fields is not None and len(self.fields) > 10:
            raise SlackObjectFormationError("fields attribute cannot exceed 10 items")
        json = super().get_json()
        if self.text is not None:
            if isinstance(self.text, TextObject):
                json["text"] = self.text.get_json()
            else:
                json["text"] = MarkdownTextObject(self.text).get_json()
        if self.fields:
            json["fields"] = [
                MarkdownTextObject(field).get_json() for field in self.fields
            ]
        if self.accessory is not None:
            json["accessory"] = self.accessory.get_json()
        return json


class ImageBlock(Block):
    def __init__(
        self,
        image_url: str,
        alt_text: str,
        title: str = None,
        block_id: str = None,
    ):
        """
        A simple image block, designed to make those cat photos really pop.
        https://api.slack.com/reference/messaging/blocks#image

        :param image_url: Publicly hosted URL to be displayed. Cannot exceed 3000
        characters.

        :param alt_text: Plain text summary of image. Cannot exceed 2000 characters.

        :param title: A title to be displayed above the image. Cannot exceed 2000
        characters.

        :param block_id: ID to be used for this block - autogenerated if left blank.
        Cannot exceed 255 characters.
        """
        super().__init__(type="image", block_id=block_id)
        self.image_url = image_url
        self.alt_text = alt_text
        self.title = title

    def get_json(self) -> dict:
        if len(self.image_url) > 3000:
            raise SlackObjectFormationError(
                "image_url attribute cannot exceed 3000 characters"
            )
        if len(self.alt_text) > 2000:
            raise SlackObjectFormationError(
                "alt_text attribute cannot exceed 2000 characters"
            )
        if self.title is not None and len(self.title) > 2000:
            raise SlackObjectFormationError(
                "title attribute cannot exceed 2000 characters"
            )
        json = super().get_json()
        json.update(self.get_non_null_keys({"image_url", "alt_text"}))
        if self.title is not None:
            json["title"] = PlainTextObject(self.title).get_json()
        return json


class ActionsBlock(Block):
    def __init__(self, elements: List[InteractiveElements], block_id: str = None):
        """
        A block that is used to hold interactive elements.
        https://api.slack.com/reference/messaging/blocks#actions

        :param elements: Up to 5 element objects - buttons, date pickers, etc

        :param block_id: ID to be used for this block - autogenerated if left blank.
        Cannot exceed 255 characters.
        """
        super().__init__(type="actions", block_id=block_id)
        self.elements = elements

    def get_json(self) -> dict:
        if len(self.elements) > 5:
            raise SlackObjectFormationError(
                "elements attribute cannot exceed 5 elements"
            )
        json = super().get_json()
        json["elements"] = [element.get_json() for element in self.elements]
        return json


class ContextBlock(Block):
    def __init__(
        self, elements: List[Union[ImageBlock, TextObject]], block_id: str = None
    ):
        """
        Displays message context, which can include both images and text.
        https://api.slack.com/reference/messaging/blocks#context

        :param elements: Up to 10 ImageElements and TextObjects

        :param block_id: ID to be used for this block - autogenerated if left blank.
        Cannot exceed 255 characters.
        """
        super().__init__(type="context", block_id=block_id)
        self.elements = elements

    def get_json(self) -> dict:
        if len(self.elements) > 10:
            raise SlackObjectFormationError(
                "elements attribute cannot exceed 10 elements"
            )
        json = super().get_json()
        json["elements"] = [element.get_json() for element in self.elements]
        return json
